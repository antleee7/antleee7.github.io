import Mathlib.Algebra.MvPolynomial.Basic
import Mathlib.Algebra.MvPolynomial.Division
import Mathlib.Algebra.MvPolynomial.CommRing
import Mathlib.Data.Finsupp.BigOperators
import Mathlib.Logic.Basic

open MvPolynomial


variable {R Ïƒ : Type*}

variable (n:â„•) [CommRing R] [LinearOrder (Fin n â†’â‚€ â„•)] (F : Finset (MvPolynomial (Fin n) R))

-- the leading exponent
def lead_exponent [LinearOrder (Fin n â†’â‚€ â„•)] (f : MvPolynomial (Fin n) R) : (Fin n â†’â‚€ â„•)
  := match f.support.max with
    | some Î± => Î±
    | none => 0


-- the coefficient of the leading exponent term
def lead_coeff (f : MvPolynomial (Fin n) R) : R
  := coeff (lead_exponent n f) f


-- the leading exponent monomial
noncomputable def hm [LinearOrder (Fin n â†’â‚€ â„•)] (f : MvPolynomial (Fin n) R) : (MvPolynomial (Fin n) R)
  := monomial (lead_exponent n f) (lead_coeff n f)


-- the leading term, WE RESERVE THE TERM TERM TO MONOMIALS WITH FIXED COEFF 1
noncomputable def ht [LinearOrder (Fin n â†’â‚€ â„•)] (f : MvPolynomial (Fin n) R) : (MvPolynomial (Fin n) R)
  := monomial (lead_exponent n f) 1

-- the ideal generated by the leading terms of polynomials in F
def initial_ideal (F : Set (MvPolynomial (Fin n) R)) : Ideal (MvPolynomial (Fin n) R)
  := Ideal.span {g| âˆƒ f âˆˆ F, g = ht n f}


-- the lcm of two monomials m1 and m2, credit to ì²œë™ìš±
def lcm {n : â„•} (m1 m2 : Fin n â†’â‚€ â„•) : Fin n â†’â‚€ â„•
  where
  support := m1.support âˆª m2.support
  toFun := Î» n => max (m1 n) (m2 n)
  mem_support_toFun := by
    intro _
    constructor
    Â· intro _ _
      simp_all
    Â· contrapose
      simp


-- a finite set G is a Grobner basis of I
def is_Grobner_basis_of (G: Finset (MvPolynomial (Fin n) R)) (I : Ideal (MvPolynomial (Fin n) R)) : Prop
  := initial_ideal n G.toSet = initial_ideal n I



-- divide a polynomial by a monomial, output its quotient (I have fixed Ïƒ = Fin n)
noncomputable def div_by_monomial (n : â„•) (p : MvPolynomial (Fin n) R) (s : Fin n â†’â‚€ â„•) : (MvPolynomial (Fin n) R)
  := AddMonoidAlgebra.divOf p s

-- output its remainder
noncomputable def mod_by_monomial (p : MvPolynomial (Fin n) R) (s : Fin n â†’â‚€ â„•) : (MvPolynomial (Fin n) R)
  := AddMonoidAlgebra.modOf p s

-- S polynomial of f and g
noncomputable def S_poly (n : â„•) [LinearOrder (Fin n â†’â‚€ â„•)] (f g : MvPolynomial (Fin n) R) : MvPolynomial (Fin n) R
  :=
  let tau := monomial (lcm (lead_exponent n f) (lead_exponent n g)) 1
  ((monomial 0 (lead_coeff n g)) * (div_by_monomial n tau (lead_exponent n f)) * f) - ((monomial 0 (lead_coeff n g)) * (div_by_monomial n tau (lead_exponent n g)) * g)


-- take input f r and G, check if r is the normal form (definition following stackexchange)

/-!def is_normal_form (f r : MvPolynomial (Fin n) R) (I : Ideal (MvPolynomial (Fin n) R)) : Prop
  := (âˆƒ g âˆˆ I, f = g + r) âˆ§
  (r = 0 âˆ¨
  âˆ€ m âˆˆ r.support, (monomial m (coeff m f)) âˆ‰ {h | âˆƒ p âˆˆ I, h = lead_monomial n p} )
-/


-- eval ftn: v : P^m â†’ P, multiplication by f1 ... fm, m-tuple
noncomputable def v_function (n m : â„•) (F G : Fin m â†’ MvPolynomial (Fin n) R) : MvPolynomial (Fin n) R
  := âˆ‘ i, (F i * G i)

-- define the extended ordering on the m-tuples of polynomials, say G and F are m-tuples, define a binary relation
-- G le F iff G's first nonzero term < F's first nonzero term, and if they appear at the same index, order with lead_term
-- for convenience, defined only for nonzero F and G

-- i is the index of G
def is_index (n m : â„•) (i : Fin m) (G : Fin m â†’ MvPolynomial (Fin n) R) : Prop
  := i âˆˆ G.support âˆ§ âˆ€ j âˆˆ G.support, i â‰¤ j




-- G < H
def tuple_lessthan [LinearOrder (Fin n â†’â‚€ â„•)] (m : â„•) (G H : Fin m â†’ MvPolynomial (Fin n) R) : Prop
  := (G.support = âˆ… âˆ§ H.support â‰  âˆ…) âˆ¨
  (
  âˆƒ i, is_index n m i G âˆ§
  âˆƒ j, is_index n m j H âˆ§
    (
    i > j âˆ¨
    i = j âˆ§ lead_exponent n (G i) < lead_exponent n (H i)
    )
  )


-- def tuple_degree (m : â„•) (F G : Fin m â†’ MvPolynomial (Fin n) R) : â„•  --> Needs degree definition for multivariate polynomials, in section 3


-- W(t) = set of g âˆˆ P^m such that lead_monomial of v(g) = t, t a monomial.
--def W_t (n m : â„•) (F : Fin m â†’ MvPolynomial (Fin n) R) (t : Fin n â†’â‚€ â„•) : Set (Fin m â†’ MvPolynomial (Fin n) R)
--:= {G | (v_function n m F G) = monomial t 1}


-- w function: set of coeff 1 monomials to P^m. input: (Fin n â†’â‚€ â„•)
-- Checks if M = m1 ... mm is the w function value of t âˆˆ T a monomial i.e., checks if M is the minimal value of the set W(t)
--def is_w_function_value (n m : â„•) [LinearOrder (Fin n â†’â‚€ â„•)] (F : Fin m â†’ MvPolynomial (Fin n) R) (t : Fin n â†’â‚€ â„•) (M : Fin m â†’ MvPolynomial (Fin n) R) : Prop
--:= âˆ€ G âˆˆ W_t n m F t, M = G âˆ¨ tuple_lessthan n m M G

-- MHT(ð•˜) = (HT(g1) ... HT(gm))
noncomputable def mht (n m : â„•) [LinearOrder (Fin n â†’â‚€ â„•)] (G : Fin m â†’ MvPolynomial (Fin n) R) : (Fin m â†’ MvPolynomial (Fin n) R)
:= Î» i â†¦ ht n (G i)

-- ordering is well founded if every nonempty subset has a minimal element
lemma tuple_order_wellfounded (n m : â„•) [LinearOrder (Fin n â†’â‚€ â„•)] : âˆ€ (P : Set (Fin m â†’ MvPolynomial (Fin n) R)), P.Nonempty â†’ âˆƒ M âˆˆ P, âˆ€ X âˆˆ P, Â¬ (tuple_lessthan n m X M)
  := Î» P hP â†¦  -- Lambda abstraction over the parameters P and hP
  let âŸ¨x, hxâŸ© := hP  -- Extract an element x from the nonempty set P
  if (âˆ€ i, x i = 0) then
  âŸ¨x, hx, fun X hX => fun contra => by exact contraâŸ©
  else sorry




  -- if x is not trivial, its index is well-defined and the set {i âˆˆ Fin m | i is the index of p âˆˆ P} is nonempty. (prove this by showing x nontrivial => support of x is nonempty) this implies that the set has a maximal element, denoted i_max
  -- consider the set {HT(p_k) | p âˆˆ P, index of p is k}. nonempty as P has x, which has a well-defined index. Use the fact that the linear order on Fin n â†’â‚€ â„• is well-ordered(which I think I have to prove again), and take t_min = min of this set wrt linear order.
  -- Define the set M = {p âˆˆ P | index(p) = i_max, HT(p_imax) = t_min}, show that there exists some element of M. Prove that M is a minimal element.



-- send signature data, of the form (Fin n â†’â‚€ â„•) Ã— (k : Fin m), to (0,...,t,...,0) âˆˆ P^m
noncomputable def sig_data_to_tuple (n m : â„•) (t : Fin n â†’â‚€ â„•) (k : Fin m) : (Fin m â†’ MvPolynomial (Fin n) R)
:= Î» i â†¦ if i â‰  k then 0 else monomial t 1

-- checks if a given element sig of ð•‹ is indeed the signature of a polynomial p, i.e., HT(w(HT(p))) = sig
-- input: signature data, F = f1 ... fm, p a poly (inside the ideal spanned by fi)
-- def has_signature (n m : â„•) [LinearOrder (Fin n â†’â‚€ â„•)] (t : Fin n â†’â‚€ â„•) (k : Fin m) (F : Fin m â†’ MvPolynomial (Fin n) R) (p : MvPolynomial (Fin n) R) : Prop
--  := p âˆˆ Ideal.span {g | âˆƒ i, F i = g} âˆ§ -- p is indeed inside âŸ¨FâŸ©
--    (
--    âˆƒ V : Fin m â†’ MvPolynomial (Fin n) R,
--    is_w_function_value n m F (lead_exponent n p) V âˆ§
--    tuple_lead_term n m V = sig_data_to_tuple n m t k
--    ) -- exists a tuple V s.t. it is the w-function value of lead_monomial p, and tuple_lead_monomial V = signature.


-- r = (signature, f) is admissible, with F = f1 ... fm
def is_admissible (n m : â„•) [LinearOrder (Fin n â†’â‚€ â„•)] (r : (Fin n â†’â‚€ â„•) Ã— Fin m Ã— MvPolynomial (Fin n) R) (F : Fin m â†’ MvPolynomial (Fin n) R) : Prop
  := âˆƒ G : Fin m â†’ MvPolynomial (Fin n) R,
  G â‰  0 âˆ§
  v_function n m F G = r.2.2 âˆ§
  mht n m G = (Î» i â†¦ if i â‰  r.2.1 then 0 else (monomial r.1 1))

-- G, finite set of labeled admissible (wrt F) polys. r is normalized wrt G if u âˆ‰ HT(Ideal.span{p_i âˆˆ poly(G) | index(ri)>index(r)}), u = signature of r = r.1
def is_normalized (n m q : â„•) [LinearOrder (Fin n â†’â‚€ â„•)] (G : Fin q â†’ (Fin n â†’â‚€ â„•) Ã— Fin m Ã— MvPolynomial (Fin n) R) (F : Fin m â†’ MvPolynomial (Fin n) R) (r : (Fin n â†’â‚€ â„•) Ã— Fin m Ã— MvPolynomial (Fin n) R) : Prop
  := âˆ€ i, is_admissible n m (G i) F âˆ§ -- components of G are admissible wrt F
  monomial r.1 1 âˆ‰ {ht n f | f âˆˆ Ideal.span {(G i).2.2 | âˆƒ k l, is_index n m k (G i) âˆ§ l is_index r âˆ§ k > l}} -- assuming G i = ri


-- (r1 r2) pair of labelled polys with tau = lcm (ht poly r1, ht poly r2) and tau_i = tau/ht(poly ri) for i = 1,2. This pair is normalized if tau1r1 tau2r2 are normalized and Signature(tau2r2) < Signature(tau1r1).
def pair_normalized (n m : â„•) (r1 r2 : (Fin n â†’â‚€ â„•) Ã— Fin m Ã— MvPolynomial (Fin n) R) : Prop
  := let tau := lcm (ht r1.2.2) (ht r2.2.2)
  let tau1 = -- tau divided by ht r1.2.2
  let tau2 = --
  tau1 is normalized âˆ§ tau2 is normalized âˆ§ signature(tau2r2) < signature(tau1r1)

noncomputable def labeled_Spoly



-- lemma: if an admissible r = (uek, p) with G âˆˆ P^m s.t. mht G = uek and v_function G = p is not normalized wrt G, then there exists s âˆˆ PSyz(F) with index(s) = k s.t. MHT(g-s) < MHT(g).

-- Nov 30 TODO: define Syz, write some proofs :(



-- P âŠ† k[x1..xn], f, t a term.
def has_t_rep (n q : â„•) [LinearOrder (Fin n â†’â‚€ â„•)] (P : Fin q â†’ MvPolynomial (Fin n) R) (f : MvPolynomial (Fin n) R) (t : Fin n â†’â‚€ â„•) : Prop
  := f = 0 âˆ¨
     f â‰  0 âˆ§
     âˆƒ L : Fin q â†’ MvPolynomial (Fin n) R, âˆ‘ i, L i * P i = f âˆ§
     âˆ€ i, L i = 0 âˆ¨
        (L i â‰  0 âˆ§ lead_exponent n (L i * P i) â‰¤ t)

-- if t = lead_exponent f, a t-rep of f is called a standard repn.

-- we assume the following theorem: G = {g1 ... g_n_G} âŠ† k[x1...xn], all gi nonzero. If every f âˆˆ I = âŸ¨GâŸ© f has a standard repn, G a GB of I.

-- thus our goal is to prove every f has a standard repn.
