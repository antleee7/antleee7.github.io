import Mathlib.Algebra.MvPolynomial.Basic
import Mathlib.Algebra.MvPolynomial.Division
import Mathlib.Algebra.MvPolynomial.CommRing
import Mathlib.Data.Finsupp.BigOperators
import Mathlib.Logic.Basic

open MvPolynomial


variable {R σ : Type*}

variable (n:ℕ) [CommRing R] [LinearOrder (Fin n →₀ ℕ)] (F : Finset (MvPolynomial (Fin n) R))

-- the leading exponent
def lead_exponent [LinearOrder (Fin n →₀ ℕ)] (f : MvPolynomial (Fin n) R) : (Fin n →₀ ℕ)
  := match f.support.max with
    | some α => α
    | none => 0


-- the coefficient of the leading exponent term
def lead_coeff (f : MvPolynomial (Fin n) R) : R
  := coeff (lead_exponent n f) f


-- the leading exponent monomial
noncomputable def hm [LinearOrder (Fin n →₀ ℕ)] (f : MvPolynomial (Fin n) R) : (MvPolynomial (Fin n) R)
  := monomial (lead_exponent n f) (lead_coeff n f)


-- the leading term, WE RESERVE THE TERM TERM TO MONOMIALS WITH FIXED COEFF 1
noncomputable def ht [LinearOrder (Fin n →₀ ℕ)] (f : MvPolynomial (Fin n) R) : (MvPolynomial (Fin n) R)
  := monomial (lead_exponent n f) 1

-- the ideal generated by the leading terms of polynomials in F
def initial_ideal (F : Set (MvPolynomial (Fin n) R)) : Ideal (MvPolynomial (Fin n) R)
  := Ideal.span {g| ∃ f ∈ F, g = ht n f}


-- the lcm of two monomials m1 and m2, credit to 천동욱
def lcm {n : ℕ} (m1 m2 : Fin n →₀ ℕ) : Fin n →₀ ℕ
  where
  support := m1.support ∪ m2.support
  toFun := λ n => max (m1 n) (m2 n)
  mem_support_toFun := by
    intro _
    constructor
    · intro _ _
      simp_all
    · contrapose
      simp


-- a finite set G is a Grobner basis of I
def is_Grobner_basis_of (G: Finset (MvPolynomial (Fin n) R)) (I : Ideal (MvPolynomial (Fin n) R)) : Prop
  := initial_ideal n G.toSet = initial_ideal n I



-- divide a polynomial by a monomial, output its quotient (I have fixed σ = Fin n)
noncomputable def div_by_monomial (n : ℕ) (p : MvPolynomial (Fin n) R) (s : Fin n →₀ ℕ) : (MvPolynomial (Fin n) R)
  := AddMonoidAlgebra.divOf p s

-- output its remainder
noncomputable def mod_by_monomial (p : MvPolynomial (Fin n) R) (s : Fin n →₀ ℕ) : (MvPolynomial (Fin n) R)
  := AddMonoidAlgebra.modOf p s

-- S polynomial of f and g
noncomputable def S_poly (n : ℕ) [LinearOrder (Fin n →₀ ℕ)] (f g : MvPolynomial (Fin n) R) : MvPolynomial (Fin n) R
  :=
  let tau := monomial (lcm (lead_exponent n f) (lead_exponent n g)) 1
  ((monomial 0 (lead_coeff n g)) * (div_by_monomial n tau (lead_exponent n f)) * f) - ((monomial 0 (lead_coeff n g)) * (div_by_monomial n tau (lead_exponent n g)) * g)


-- take input f r and G, check if r is the normal form (definition following stackexchange)

/-!def is_normal_form (f r : MvPolynomial (Fin n) R) (I : Ideal (MvPolynomial (Fin n) R)) : Prop
  := (∃ g ∈ I, f = g + r) ∧
  (r = 0 ∨
  ∀ m ∈ r.support, (monomial m (coeff m f)) ∉ {h | ∃ p ∈ I, h = lead_monomial n p} )
-/


-- eval ftn: v : P^m → P, multiplication by f1 ... fm, m-tuple
noncomputable def v_function (n m : ℕ) (F G : Fin m → MvPolynomial (Fin n) R) : MvPolynomial (Fin n) R
  := ∑ i, (F i * G i)

-- define the extended ordering on the m-tuples of polynomials, say G and F are m-tuples, define a binary relation
-- G le F iff G's first nonzero term < F's first nonzero term, and if they appear at the same index, order with lead_term
-- for convenience, defined only for nonzero F and G

-- i is the index of G
def is_index (n m : ℕ) (i : Fin m) (G : Fin m → MvPolynomial (Fin n) R) : Prop
  := i ∈ G.support ∧ ∀ j ∈ G.support, i ≤ j




-- G < H
def tuple_lessthan [LinearOrder (Fin n →₀ ℕ)] (m : ℕ) (G H : Fin m → MvPolynomial (Fin n) R) : Prop
  := (G.support = ∅ ∧ H.support ≠ ∅) ∨
  (
  ∃ i, is_index n m i G ∧
  ∃ j, is_index n m j H ∧
    (
    i > j ∨
    i = j ∧ lead_exponent n (G i) < lead_exponent n (H i)
    )
  )


-- def tuple_degree (m : ℕ) (F G : Fin m → MvPolynomial (Fin n) R) : ℕ  --> Needs degree definition for multivariate polynomials, in section 3


-- W(t) = set of g ∈ P^m such that lead_monomial of v(g) = t, t a monomial.
--def W_t (n m : ℕ) (F : Fin m → MvPolynomial (Fin n) R) (t : Fin n →₀ ℕ) : Set (Fin m → MvPolynomial (Fin n) R)
--:= {G | (v_function n m F G) = monomial t 1}


-- w function: set of coeff 1 monomials to P^m. input: (Fin n →₀ ℕ)
-- Checks if M = m1 ... mm is the w function value of t ∈ T a monomial i.e., checks if M is the minimal value of the set W(t)
--def is_w_function_value (n m : ℕ) [LinearOrder (Fin n →₀ ℕ)] (F : Fin m → MvPolynomial (Fin n) R) (t : Fin n →₀ ℕ) (M : Fin m → MvPolynomial (Fin n) R) : Prop
--:= ∀ G ∈ W_t n m F t, M = G ∨ tuple_lessthan n m M G

-- MHT(𝕘) = (HT(g1) ... HT(gm))
noncomputable def mht (n m : ℕ) [LinearOrder (Fin n →₀ ℕ)] (G : Fin m → MvPolynomial (Fin n) R) : (Fin m → MvPolynomial (Fin n) R)
:= λ i ↦ ht n (G i)

-- ordering is well founded if every nonempty subset has a minimal element
lemma tuple_order_wellfounded (n m : ℕ) [LinearOrder (Fin n →₀ ℕ)] : ∀ (P : Set (Fin m → MvPolynomial (Fin n) R)), P.Nonempty → ∃ M ∈ P, ∀ X ∈ P, ¬ (tuple_lessthan n m X M)
  := λ P hP ↦  -- Lambda abstraction over the parameters P and hP
  let ⟨x, hx⟩ := hP  -- Extract an element x from the nonempty set P
  if (∀ i, x i = 0) then
  ⟨x, hx, fun X hX => fun contra => by exact contra⟩
  else sorry




  -- if x is not trivial, its index is well-defined and the set {i ∈ Fin m | i is the index of p ∈ P} is nonempty. (prove this by showing x nontrivial => support of x is nonempty) this implies that the set has a maximal element, denoted i_max
  -- consider the set {HT(p_k) | p ∈ P, index of p is k}. nonempty as P has x, which has a well-defined index. Use the fact that the linear order on Fin n →₀ ℕ is well-ordered(which I think I have to prove again), and take t_min = min of this set wrt linear order.
  -- Define the set M = {p ∈ P | index(p) = i_max, HT(p_imax) = t_min}, show that there exists some element of M. Prove that M is a minimal element.



-- send signature data, of the form (Fin n →₀ ℕ) × (k : Fin m), to (0,...,t,...,0) ∈ P^m
noncomputable def sig_data_to_tuple (n m : ℕ) (t : Fin n →₀ ℕ) (k : Fin m) : (Fin m → MvPolynomial (Fin n) R)
:= λ i ↦ if i ≠ k then 0 else monomial t 1

-- checks if a given element sig of 𝕋 is indeed the signature of a polynomial p, i.e., HT(w(HT(p))) = sig
-- input: signature data, F = f1 ... fm, p a poly (inside the ideal spanned by fi)
-- def has_signature (n m : ℕ) [LinearOrder (Fin n →₀ ℕ)] (t : Fin n →₀ ℕ) (k : Fin m) (F : Fin m → MvPolynomial (Fin n) R) (p : MvPolynomial (Fin n) R) : Prop
--  := p ∈ Ideal.span {g | ∃ i, F i = g} ∧ -- p is indeed inside ⟨F⟩
--    (
--    ∃ V : Fin m → MvPolynomial (Fin n) R,
--    is_w_function_value n m F (lead_exponent n p) V ∧
--    tuple_lead_term n m V = sig_data_to_tuple n m t k
--    ) -- exists a tuple V s.t. it is the w-function value of lead_monomial p, and tuple_lead_monomial V = signature.


-- r = (signature, f) is admissible, with F = f1 ... fm
def is_admissible (n m : ℕ) [LinearOrder (Fin n →₀ ℕ)] (r : (Fin n →₀ ℕ) × Fin m × MvPolynomial (Fin n) R) (F : Fin m → MvPolynomial (Fin n) R) : Prop
  := ∃ G : Fin m → MvPolynomial (Fin n) R,
  G ≠ 0 ∧
  v_function n m F G = r.2.2 ∧
  mht n m G = (λ i ↦ if i ≠ r.2.1 then 0 else (monomial r.1 1))

-- G, finite set of labeled admissible (wrt F) polys. r is normalized wrt G if u ∉ HT(Ideal.span{p_i ∈ poly(G) | index(ri)>index(r)}), u = signature of r = r.1
def is_normalized (n m q : ℕ) [LinearOrder (Fin n →₀ ℕ)] (G : Fin q → (Fin n →₀ ℕ) × Fin m × MvPolynomial (Fin n) R) (F : Fin m → MvPolynomial (Fin n) R) (r : (Fin n →₀ ℕ) × Fin m × MvPolynomial (Fin n) R) : Prop
  := ∀ i, is_admissible n m (G i) F ∧ -- components of G are admissible wrt F
  monomial r.1 1 ∉ {ht n f | f ∈ Ideal.span {(G i).2.2 | ∃ k l, is_index n m k (G i) ∧ l is_index r ∧ k > l}} -- assuming G i = ri


-- (r1 r2) pair of labelled polys with tau = lcm (ht poly r1, ht poly r2) and tau_i = tau/ht(poly ri) for i = 1,2. This pair is normalized if tau1r1 tau2r2 are normalized and Signature(tau2r2) < Signature(tau1r1).
def pair_normalized (n m : ℕ) (r1 r2 : (Fin n →₀ ℕ) × Fin m × MvPolynomial (Fin n) R) : Prop
  := let tau := lcm (ht r1.2.2) (ht r2.2.2)
  let tau1 = -- tau divided by ht r1.2.2
  let tau2 = --
  tau1 is normalized ∧ tau2 is normalized ∧ signature(tau2r2) < signature(tau1r1)

noncomputable def labeled_Spoly



-- lemma: if an admissible r = (uek, p) with G ∈ P^m s.t. mht G = uek and v_function G = p is not normalized wrt G, then there exists s ∈ PSyz(F) with index(s) = k s.t. MHT(g-s) < MHT(g).

-- Nov 30 TODO: define Syz, write some proofs :(



-- P ⊆ k[x1..xn], f, t a term.
def has_t_rep (n q : ℕ) [LinearOrder (Fin n →₀ ℕ)] (P : Fin q → MvPolynomial (Fin n) R) (f : MvPolynomial (Fin n) R) (t : Fin n →₀ ℕ) : Prop
  := f = 0 ∨
     f ≠ 0 ∧
     ∃ L : Fin q → MvPolynomial (Fin n) R, ∑ i, L i * P i = f ∧
     ∀ i, L i = 0 ∨
        (L i ≠ 0 ∧ lead_exponent n (L i * P i) ≤ t)

-- if t = lead_exponent f, a t-rep of f is called a standard repn.

-- we assume the following theorem: G = {g1 ... g_n_G} ⊆ k[x1...xn], all gi nonzero. If every f ∈ I = ⟨G⟩ f has a standard repn, G a GB of I.

-- thus our goal is to prove every f has a standard repn.
